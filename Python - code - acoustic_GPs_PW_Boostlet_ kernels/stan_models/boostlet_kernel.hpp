// Code generated by stanc v2.33.1
#include <stan/model/model_header.hpp>
namespace boostlet_kernel_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 147> locations_array__ =
  {" (found before start of program)",
  " (in 'boostlet_kernel.stan', line 123, column 2 to column 29)",
  " (in 'boostlet_kernel.stan', line 124, column 2 to column 22)",
  " (in 'boostlet_kernel.stan', line 128, column 2 to column 32)",
  " (in 'boostlet_kernel.stan', line 129, column 2 to column 36)",
  " (in 'boostlet_kernel.stan', line 130, column 2 to column 35)",
  " (in 'boostlet_kernel.stan', line 131, column 2 to column 33)",
  " (in 'boostlet_kernel.stan', line 132, column 2 to column 36)",
  " (in 'boostlet_kernel.stan', line 134, column 2 to column 91)",
  " (in 'boostlet_kernel.stan', line 135, column 2 to column 93)",
  " (in 'boostlet_kernel.stan', line 137, column 2 to column 102)",
  " (in 'boostlet_kernel.stan', line 139, column 2 to column 24)",
  " (in 'boostlet_kernel.stan', line 143, column 2 to column 39)",
  " (in 'boostlet_kernel.stan', line 144, column 2 to column 40)",
  " (in 'boostlet_kernel.stan', line 146, column 6 to column 52)",
  " (in 'boostlet_kernel.stan', line 145, column 24 to line 147, column 7)",
  " (in 'boostlet_kernel.stan', line 145, column 2 to line 147, column 7)",
  " (in 'boostlet_kernel.stan', line 76, column 2 to column 22)",
  " (in 'boostlet_kernel.stan', line 77, column 2 to column 22)",
  " (in 'boostlet_kernel.stan', line 78, column 2 to column 22)",
  " (in 'boostlet_kernel.stan', line 79, column 2 to column 19)",
  " (in 'boostlet_kernel.stan', line 80, column 2 to column 17)",
  " (in 'boostlet_kernel.stan', line 81, column 8 to column 14)",
  " (in 'boostlet_kernel.stan', line 81, column 23 to column 33)",
  " (in 'boostlet_kernel.stan', line 81, column 2 to column 42)",
  " (in 'boostlet_kernel.stan', line 82, column 8 to column 14)",
  " (in 'boostlet_kernel.stan', line 82, column 2 to column 28)",
  " (in 'boostlet_kernel.stan', line 83, column 8 to column 14)",
  " (in 'boostlet_kernel.stan', line 83, column 2 to column 28)",
  " (in 'boostlet_kernel.stan', line 84, column 8 to column 9)",
  " (in 'boostlet_kernel.stan', line 84, column 2 to column 37)",
  " (in 'boostlet_kernel.stan', line 85, column 9 to column 19)",
  " (in 'boostlet_kernel.stan', line 85, column 21 to column 31)",
  " (in 'boostlet_kernel.stan', line 85, column 2 to column 44)",
  " (in 'boostlet_kernel.stan', line 86, column 2 to column 9)",
  " (in 'boostlet_kernel.stan', line 87, column 2 to column 17)",
  " (in 'boostlet_kernel.stan', line 88, column 2 to column 18)",
  " (in 'boostlet_kernel.stan', line 89, column 2 to column 13)",
  " (in 'boostlet_kernel.stan', line 90, column 9 to column 12)",
  " (in 'boostlet_kernel.stan', line 90, column 2 to column 16)",
  " (in 'boostlet_kernel.stan', line 91, column 9 to column 12)",
  " (in 'boostlet_kernel.stan', line 91, column 2 to column 18)",
  " (in 'boostlet_kernel.stan', line 95, column 9 to column 19)",
  " (in 'boostlet_kernel.stan', line 95, column 2 to column 52)",
  " (in 'boostlet_kernel.stan', line 96, column 8 to column 14)",
  " (in 'boostlet_kernel.stan', line 96, column 23 to column 24)",
  " (in 'boostlet_kernel.stan', line 96, column 2 to column 38)",
  " (in 'boostlet_kernel.stan', line 97, column 8 to column 14)",
  " (in 'boostlet_kernel.stan', line 97, column 23 to column 24)",
  " (in 'boostlet_kernel.stan', line 97, column 2 to column 38)",
  " (in 'boostlet_kernel.stan', line 98, column 8 to column 11)",
  " (in 'boostlet_kernel.stan', line 98, column 2 to column 26)",
  " (in 'boostlet_kernel.stan', line 99, column 8 to column 11)",
  " (in 'boostlet_kernel.stan', line 99, column 2 to column 28)",
  " (in 'boostlet_kernel.stan', line 103, column 6 to column 58)",
  " (in 'boostlet_kernel.stan', line 102, column 19 to line 104, column 5)",
  " (in 'boostlet_kernel.stan', line 102, column 4 to line 104, column 5)",
  " (in 'boostlet_kernel.stan', line 101, column 22 to line 105, column 3)",
  " (in 'boostlet_kernel.stan', line 101, column 2 to line 105, column 3)",
  " (in 'boostlet_kernel.stan', line 109, column 6 to column 58)",
  " (in 'boostlet_kernel.stan', line 108, column 19 to line 110, column 5)",
  " (in 'boostlet_kernel.stan', line 108, column 4 to line 110, column 5)",
  " (in 'boostlet_kernel.stan', line 107, column 22 to line 111, column 3)",
  " (in 'boostlet_kernel.stan', line 107, column 2 to line 111, column 3)",
  " (in 'boostlet_kernel.stan', line 114, column 4 to column 22)",
  " (in 'boostlet_kernel.stan', line 113, column 19 to line 115, column 3)",
  " (in 'boostlet_kernel.stan', line 113, column 2 to line 115, column 3)",
  " (in 'boostlet_kernel.stan', line 118, column 4 to column 26)",
  " (in 'boostlet_kernel.stan', line 117, column 19 to line 119, column 3)",
  " (in 'boostlet_kernel.stan', line 117, column 2 to line 119, column 3)",
  " (in 'boostlet_kernel.stan', line 123, column 18 to column 19)",
  " (in 'boostlet_kernel.stan', line 128, column 9 to column 15)",
  " (in 'boostlet_kernel.stan', line 128, column 17 to column 23)",
  " (in 'boostlet_kernel.stan', line 129, column 9 to column 15)",
  " (in 'boostlet_kernel.stan', line 129, column 17 to column 23)",
  " (in 'boostlet_kernel.stan', line 130, column 9 to column 19)",
  " (in 'boostlet_kernel.stan', line 130, column 21 to column 31)",
  " (in 'boostlet_kernel.stan', line 131, column 9 to column 17)",
  " (in 'boostlet_kernel.stan', line 131, column 19 to column 27)",
  " (in 'boostlet_kernel.stan', line 3, column 4 to column 20)",
  " (in 'boostlet_kernel.stan', line 4, column 4 to column 31)",
  " (in 'boostlet_kernel.stan', line 5, column 4 to column 29)",
  " (in 'boostlet_kernel.stan', line 7, column 11 to column 12)",
  " (in 'boostlet_kernel.stan', line 7, column 14 to column 15)",
  " (in 'boostlet_kernel.stan', line 7, column 4 to column 19)",
  " (in 'boostlet_kernel.stan', line 14, column 10 to column 22)",
  " (in 'boostlet_kernel.stan', line 18, column 16 to column 96)",
  " (in 'boostlet_kernel.stan', line 17, column 30 to line 19, column 15)",
  " (in 'boostlet_kernel.stan', line 17, column 14 to line 19, column 15)",
  " (in 'boostlet_kernel.stan', line 16, column 28 to line 20, column 13)",
  " (in 'boostlet_kernel.stan', line 16, column 12 to line 20, column 13)",
  " (in 'boostlet_kernel.stan', line 15, column 25 to line 21, column 11)",
  " (in 'boostlet_kernel.stan', line 15, column 10 to line 21, column 11)",
  " (in 'boostlet_kernel.stan', line 13, column 36 to line 22, column 9)",
  " (in 'boostlet_kernel.stan', line 13, column 15 to line 22, column 9)",
  " (in 'boostlet_kernel.stan', line 12, column 10 to column 37)",
  " (in 'boostlet_kernel.stan', line 11, column 20 to line 13, column 9)",
  " (in 'boostlet_kernel.stan', line 11, column 8 to line 22, column 9)",
  " (in 'boostlet_kernel.stan', line 24, column 10 to column 28)",
  " (in 'boostlet_kernel.stan', line 23, column 30 to line 25, column 9)",
  " (in 'boostlet_kernel.stan', line 23, column 8 to line 25, column 9)",
  " (in 'boostlet_kernel.stan', line 10, column 21 to line 26, column 7)",
  " (in 'boostlet_kernel.stan', line 10, column 6 to line 26, column 7)",
  " (in 'boostlet_kernel.stan', line 9, column 19 to line 27, column 5)",
  " (in 'boostlet_kernel.stan', line 9, column 4 to line 27, column 5)",
  " (in 'boostlet_kernel.stan', line 28, column 4 to column 13)",
  " (in 'boostlet_kernel.stan', line 2, column 109 to line 29, column 3)",
  " (in 'boostlet_kernel.stan', line 32, column 4 to column 20)",
  " (in 'boostlet_kernel.stan', line 33, column 4 to column 31)",
  " (in 'boostlet_kernel.stan', line 34, column 4 to column 29)",
  " (in 'boostlet_kernel.stan', line 36, column 11 to column 12)",
  " (in 'boostlet_kernel.stan', line 36, column 14 to column 15)",
  " (in 'boostlet_kernel.stan', line 36, column 4 to column 19)",
  " (in 'boostlet_kernel.stan', line 43, column 10 to column 22)",
  " (in 'boostlet_kernel.stan', line 47, column 16 to column 96)",
  " (in 'boostlet_kernel.stan', line 46, column 30 to line 48, column 15)",
  " (in 'boostlet_kernel.stan', line 46, column 14 to line 48, column 15)",
  " (in 'boostlet_kernel.stan', line 45, column 28 to line 49, column 13)",
  " (in 'boostlet_kernel.stan', line 45, column 12 to line 49, column 13)",
  " (in 'boostlet_kernel.stan', line 44, column 25 to line 50, column 11)",
  " (in 'boostlet_kernel.stan', line 44, column 10 to line 50, column 11)",
  " (in 'boostlet_kernel.stan', line 42, column 36 to line 51, column 9)",
  " (in 'boostlet_kernel.stan', line 42, column 15 to line 51, column 9)",
  " (in 'boostlet_kernel.stan', line 41, column 10 to column 22)",
  " (in 'boostlet_kernel.stan', line 40, column 20 to line 42, column 9)",
  " (in 'boostlet_kernel.stan', line 40, column 8 to line 51, column 9)",
  " (in 'boostlet_kernel.stan', line 53, column 10 to column 28)",
  " (in 'boostlet_kernel.stan', line 52, column 30 to line 54, column 9)",
  " (in 'boostlet_kernel.stan', line 52, column 8 to line 54, column 9)",
  " (in 'boostlet_kernel.stan', line 39, column 21 to line 55, column 7)",
  " (in 'boostlet_kernel.stan', line 39, column 6 to line 55, column 7)",
  " (in 'boostlet_kernel.stan', line 38, column 19 to line 56, column 5)",
  " (in 'boostlet_kernel.stan', line 38, column 4 to line 56, column 5)",
  " (in 'boostlet_kernel.stan', line 57, column 4 to column 13)",
  " (in 'boostlet_kernel.stan', line 31, column 107 to line 58, column 3)",
  " (in 'boostlet_kernel.stan', line 61, column 4 to column 20)",
  " (in 'boostlet_kernel.stan', line 62, column 4 to column 20)",
  " (in 'boostlet_kernel.stan', line 63, column 11 to column 12)",
  " (in 'boostlet_kernel.stan', line 63, column 14 to column 15)",
  " (in 'boostlet_kernel.stan', line 63, column 4 to column 19)",
  " (in 'boostlet_kernel.stan', line 64, column 11 to column 12)",
  " (in 'boostlet_kernel.stan', line 64, column 14 to column 15)",
  " (in 'boostlet_kernel.stan', line 64, column 4 to column 19)",
  " (in 'boostlet_kernel.stan', line 67, column 4 to column 21)",
  " (in 'boostlet_kernel.stan', line 68, column 4 to column 21)",
  " (in 'boostlet_kernel.stan', line 71, column 4 to column 13)",
  " (in 'boostlet_kernel.stan', line 60, column 32 to line 72, column 3)"};
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::is_col_vector<stan::value_type_t<T1__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T1__>>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>,
                stan::base_type_t<T3__>, stan::base_type_t<T4__>>,-1,-1>
cosine_kernel(const T0__& y, const T1__& t, const T2__& sigma_w_arg__,
              const T3__& k, const T4__& ome, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::is_col_vector<stan::value_type_t<T1__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T1__>>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>,
                stan::base_type_t<T3__>, stan::base_type_t<T4__>>,-1,-1>
sine_kernel(const T0__& y, const T1__& t, const T2__& sigma_w_arg__,
            const T3__& k, const T4__& ome, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
qr_decompose(const T0__& K_arg__, std::ostream* pstream__);
/* matrix
   cosine_kernel(array[] vector, array[] vector, vector, array[] real,
                 array[] real)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::is_col_vector<stan::value_type_t<T1__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T1__>>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>,
                stan::base_type_t<T3__>, stan::base_type_t<T4__>>,-1,-1>
cosine_kernel(const T0__& y, const T1__& t, const T2__& sigma_w_arg__,
              const T3__& k, const T4__& ome, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>,
                             stan::base_type_t<T4__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& sigma_w = stan::math::to_ref(sigma_w_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 79;
    N = stan::math::size(y);
    int D = std::numeric_limits<int>::min();
    current_statement__ = 80;
    D = stan::math::num_elements(
          stan::model::rvalue(y, "y", stan::model::index_uni(1)));
    int Ln = std::numeric_limits<int>::min();
    current_statement__ = 81;
    Ln = stan::math::num_elements(k);
    current_statement__ = 82;
    stan::math::validate_non_negative_index("K", "N", N);
    current_statement__ = 83;
    stan::math::validate_non_negative_index("K", "N", N);
    Eigen::Matrix<local_scalar_t__,-1,-1> K =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
    current_statement__ = 104;
    for (int i = 1; i <= N; ++i) {
      current_statement__ = 102;
      for (int j = 1; j <= N; ++j) {
        current_statement__ = 97;
        if (stan::math::logical_eq(i, j)) {
          current_statement__ = 95;
          stan::model::assign(K,
            stan::math::pow(stan::math::sum(sigma_w), 2),
            "assigning variable K", stan::model::index_uni(i),
            stan::model::index_uni(j));
        } else {
          current_statement__ = 94;
          if ((stan::math::primitive_value(stan::math::logical_lt(i, j)) &&
              stan::math::primitive_value(stan::math::logical_lte(j, N)))) {
            current_statement__ = 85;
            stan::model::assign(K, 0, "assigning variable K",
              stan::model::index_uni(i), stan::model::index_uni(j));
            current_statement__ = 92;
            for (int d = 1; d <= D; ++d) {
              current_statement__ = 90;
              for (int n = 1; n <= Ln; ++n) {
                current_statement__ = 88;
                for (int m = 1; m <= Ln; ++m) {
                  current_statement__ = 86;
                  stan::model::assign(K,
                    (stan::model::rvalue(K, "K", stan::model::index_uni(i),
                       stan::model::index_uni(j)) +
                    (stan::math::square(
                       stan::model::rvalue(sigma_w, "sigma_w",
                         stan::model::index_uni(d))) *
                    stan::math::cos(
                      ((stan::model::rvalue(ome, "ome",
                          stan::model::index_uni(n)) *
                      -(stan::model::rvalue(
                          stan::model::rvalue(t, "t",
                            stan::model::index_uni(j)), "t[j]",
                          stan::model::index_uni(d)))) +
                      (stan::model::rvalue(k, "k", stan::model::index_uni(m))
                      *
                      stan::model::rvalue(
                        stan::model::rvalue(y, "y", stan::model::index_uni(i)),
                        "y[i]", stan::model::index_uni(d))))))),
                    "assigning variable K", stan::model::index_uni(i),
                    stan::model::index_uni(j));
                }
              }
            }
          }
        }
        current_statement__ = 100;
        if ((stan::math::primitive_value(stan::math::logical_lte(i, N)) &&
            stan::math::primitive_value(stan::math::logical_lte(j, N)))) {
          current_statement__ = 98;
          stan::model::assign(K,
            stan::model::rvalue(K, "K", stan::model::index_uni(i),
              stan::model::index_uni(j)), "assigning variable K",
            stan::model::index_uni(j), stan::model::index_uni(i));
        }
      }
    }
    current_statement__ = 105;
    return K;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* matrix
   sine_kernel(array[] vector, array[] vector, vector, array[] real,
               array[] real)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::is_col_vector<stan::value_type_t<T1__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T1__>>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>,
                stan::base_type_t<T3__>, stan::base_type_t<T4__>>,-1,-1>
sine_kernel(const T0__& y, const T1__& t, const T2__& sigma_w_arg__,
            const T3__& k, const T4__& ome, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>,
                             stan::base_type_t<T4__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& sigma_w = stan::math::to_ref(sigma_w_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 107;
    N = stan::math::size(y);
    int D = std::numeric_limits<int>::min();
    current_statement__ = 108;
    D = stan::math::num_elements(
          stan::model::rvalue(y, "y", stan::model::index_uni(1)));
    int Ln = std::numeric_limits<int>::min();
    current_statement__ = 109;
    Ln = stan::math::num_elements(k);
    current_statement__ = 110;
    stan::math::validate_non_negative_index("K", "N", N);
    current_statement__ = 111;
    stan::math::validate_non_negative_index("K", "N", N);
    Eigen::Matrix<local_scalar_t__,-1,-1> K =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
    current_statement__ = 132;
    for (int i = 1; i <= N; ++i) {
      current_statement__ = 130;
      for (int j = 1; j <= N; ++j) {
        current_statement__ = 125;
        if (stan::math::logical_eq(i, j)) {
          current_statement__ = 123;
          stan::model::assign(K, 0, "assigning variable K",
            stan::model::index_uni(i), stan::model::index_uni(j));
        } else {
          current_statement__ = 122;
          if ((stan::math::primitive_value(stan::math::logical_lt(i, j)) &&
              stan::math::primitive_value(stan::math::logical_lte(j, N)))) {
            current_statement__ = 113;
            stan::model::assign(K, 0, "assigning variable K",
              stan::model::index_uni(i), stan::model::index_uni(j));
            current_statement__ = 120;
            for (int d = 1; d <= D; ++d) {
              current_statement__ = 118;
              for (int n = 1; n <= Ln; ++n) {
                current_statement__ = 116;
                for (int m = 1; m <= Ln; ++m) {
                  current_statement__ = 114;
                  stan::model::assign(K,
                    (stan::model::rvalue(K, "K", stan::model::index_uni(i),
                       stan::model::index_uni(j)) +
                    (stan::math::square(
                       stan::model::rvalue(sigma_w, "sigma_w",
                         stan::model::index_uni(d))) *
                    stan::math::sin(
                      ((stan::model::rvalue(ome, "ome",
                          stan::model::index_uni(n)) *
                      -(stan::model::rvalue(
                          stan::model::rvalue(t, "t",
                            stan::model::index_uni(j)), "t[j]",
                          stan::model::index_uni(d)))) +
                      (stan::model::rvalue(k, "k", stan::model::index_uni(m))
                      *
                      stan::model::rvalue(
                        stan::model::rvalue(y, "y", stan::model::index_uni(i)),
                        "y[i]", stan::model::index_uni(d))))))),
                    "assigning variable K", stan::model::index_uni(i),
                    stan::model::index_uni(j));
                }
              }
            }
          }
        }
        current_statement__ = 128;
        if ((stan::math::primitive_value(stan::math::logical_lte(i, N)) &&
            stan::math::primitive_value(stan::math::logical_lte(j, N)))) {
          current_statement__ = 126;
          stan::model::assign(K,
            stan::model::rvalue(K, "K", stan::model::index_uni(i),
              stan::model::index_uni(j)), "assigning variable K",
            stan::model::index_uni(j), stan::model::index_uni(i));
        }
      }
    }
    current_statement__ = 133;
    return K;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix qr_decompose(matrix)
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
qr_decompose(const T0__& K_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& K = stan::math::to_ref(K_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int m = std::numeric_limits<int>::min();
    current_statement__ = 135;
    m = stan::math::rows(K);
    int n = std::numeric_limits<int>::min();
    current_statement__ = 136;
    n = stan::math::cols(K);
    current_statement__ = 137;
    stan::math::validate_non_negative_index("Q", "m", m);
    current_statement__ = 138;
    stan::math::validate_non_negative_index("Q", "m", m);
    Eigen::Matrix<local_scalar_t__,-1,-1> Q =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, m, DUMMY_VAR__);
    current_statement__ = 140;
    stan::math::validate_non_negative_index("R", "m", m);
    current_statement__ = 141;
    stan::math::validate_non_negative_index("R", "n", n);
    Eigen::Matrix<local_scalar_t__,-1,-1> R =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, n, DUMMY_VAR__);
    current_statement__ = 143;
    stan::model::assign(Q, stan::math::qr_thin_Q(K), "assigning variable Q");
    current_statement__ = 144;
    stan::model::assign(R, stan::math::qr_thin_R(K), "assigning variable R");
    current_statement__ = 145;
    return R;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class boostlet_kernel_model final : public model_base_crtp<boostlet_kernel_model> {
 private:
  int N_meas;
  int N_time;
  int N_reps;
  int N_f;
  int D;
  std::vector<Eigen::Matrix<double,-1,1>> h_stan;
  std::vector<Eigen::Matrix<double,-1,1>> y;
  std::vector<Eigen::Matrix<double,-1,1>> t;
  std::vector<Eigen::Matrix<double,-1,1>> wave_directions;
  Eigen::Matrix<double,-1,-1> Sigma_stan_data__;
  double a;
  double b_log_std;
  double b_log_mean;
  double delta;
  Eigen::Matrix<double,-1,1> k_data__;
  Eigen::Matrix<double,-1,1> ome_data__;
  Eigen::Matrix<double,-1,1> mu_data__;
  std::vector<Eigen::Matrix<double,-1,1>> y_projected;
  std::vector<Eigen::Matrix<double,-1,1>> t_projected;
  std::vector<double> k_array;
  std::vector<double> ome_array;
  int K_1dim__;
  int K_2dim__;
  int L_K_1dim__;
  int L_K_2dim__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> Sigma_stan{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> k{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> ome{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> mu{nullptr, 0};
 public:
  ~boostlet_kernel_model() {}
  boostlet_kernel_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "boostlet_kernel_model_namespace::boostlet_kernel_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 17;
      context__.validate_dims("data initialization", "N_meas", "int",
        std::vector<size_t>{});
      N_meas = std::numeric_limits<int>::min();
      current_statement__ = 17;
      N_meas = context__.vals_i("N_meas")[(1 - 1)];
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "N_meas", N_meas, 0);
      current_statement__ = 18;
      context__.validate_dims("data initialization", "N_time", "int",
        std::vector<size_t>{});
      N_time = std::numeric_limits<int>::min();
      current_statement__ = 18;
      N_time = context__.vals_i("N_time")[(1 - 1)];
      current_statement__ = 18;
      stan::math::check_greater_or_equal(function__, "N_time", N_time, 0);
      current_statement__ = 19;
      context__.validate_dims("data initialization", "N_reps", "int",
        std::vector<size_t>{});
      N_reps = std::numeric_limits<int>::min();
      current_statement__ = 19;
      N_reps = context__.vals_i("N_reps")[(1 - 1)];
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "N_reps", N_reps, 0);
      current_statement__ = 20;
      context__.validate_dims("data initialization", "N_f", "int",
        std::vector<size_t>{});
      N_f = std::numeric_limits<int>::min();
      current_statement__ = 20;
      N_f = context__.vals_i("N_f")[(1 - 1)];
      current_statement__ = 20;
      stan::math::check_greater_or_equal(function__, "N_f", N_f, 0);
      current_statement__ = 21;
      context__.validate_dims("data initialization", "D", "int",
        std::vector<size_t>{});
      D = std::numeric_limits<int>::min();
      current_statement__ = 21;
      D = context__.vals_i("D")[(1 - 1)];
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "D", D, 0);
      current_statement__ = 22;
      stan::math::validate_non_negative_index("h_stan", "N_meas", N_meas);
      current_statement__ = 23;
      stan::math::validate_non_negative_index("h_stan", "2 * N_time", (2 *
        N_time));
      current_statement__ = 24;
      context__.validate_dims("data initialization", "h_stan", "double",
        std::vector<size_t>{static_cast<size_t>(N_meas),
          static_cast<size_t>((2 * N_time))});
      h_stan = std::vector<Eigen::Matrix<double,-1,1>>(N_meas,
                 Eigen::Matrix<double,-1,1>::Constant((2 * N_time),
                   std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> h_stan_flat__;
        current_statement__ = 24;
        h_stan_flat__ = context__.vals_r("h_stan");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= (2 * N_time); ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N_meas; ++sym2__) {
            stan::model::assign(h_stan, h_stan_flat__[(pos__ - 1)],
              "assigning variable h_stan", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 25;
      stan::math::validate_non_negative_index("y", "N_meas", N_meas);
      current_statement__ = 26;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(N_meas),
          static_cast<size_t>(1)});
      y = std::vector<Eigen::Matrix<double,-1,1>>(N_meas,
            Eigen::Matrix<double,-1,1>::Constant(1,
              std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 26;
        y_flat__ = context__.vals_r("y");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N_meas; ++sym2__) {
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 27;
      stan::math::validate_non_negative_index("t", "N_time", N_time);
      current_statement__ = 28;
      context__.validate_dims("data initialization", "t", "double",
        std::vector<size_t>{static_cast<size_t>(N_time),
          static_cast<size_t>(1)});
      t = std::vector<Eigen::Matrix<double,-1,1>>(N_time,
            Eigen::Matrix<double,-1,1>::Constant(1,
              std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> t_flat__;
        current_statement__ = 28;
        t_flat__ = context__.vals_r("t");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N_time; ++sym2__) {
            stan::model::assign(t, t_flat__[(pos__ - 1)],
              "assigning variable t", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 29;
      stan::math::validate_non_negative_index("wave_directions", "D", D);
      current_statement__ = 30;
      context__.validate_dims("data initialization", "wave_directions",
        "double",
        std::vector<size_t>{static_cast<size_t>(D), static_cast<size_t>(2)});
      wave_directions = std::vector<Eigen::Matrix<double,-1,1>>(D,
                          Eigen::Matrix<double,-1,1>::Constant(2,
                            std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> wave_directions_flat__;
        current_statement__ = 30;
        wave_directions_flat__ = context__.vals_r("wave_directions");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= D; ++sym2__) {
            stan::model::assign(wave_directions,
              wave_directions_flat__[(pos__ - 1)],
              "assigning variable wave_directions",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 31;
      stan::math::validate_non_negative_index("Sigma_stan", "2 * N_meas", (2
        * N_meas));
      current_statement__ = 32;
      stan::math::validate_non_negative_index("Sigma_stan", "2 * N_time", (2
        * N_time));
      current_statement__ = 33;
      context__.validate_dims("data initialization", "Sigma_stan", "double",
        std::vector<size_t>{static_cast<size_t>((2 * N_meas)),
          static_cast<size_t>((2 * N_time))});
      Sigma_stan_data__ = Eigen::Matrix<double,-1,-1>::Constant((2 * N_meas),
                            (2 * N_time),
                            std::numeric_limits<double>::quiet_NaN());
      new (&Sigma_stan)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(Sigma_stan_data__.data(), (2
        * N_meas), (2 * N_time));
      {
        std::vector<local_scalar_t__> Sigma_stan_flat__;
        current_statement__ = 33;
        Sigma_stan_flat__ = context__.vals_r("Sigma_stan");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= (2 * N_time); ++sym1__) {
          for (int sym2__ = 1; sym2__ <= (2 * N_meas); ++sym2__) {
            stan::model::assign(Sigma_stan, Sigma_stan_flat__[(pos__ - 1)],
              "assigning variable Sigma_stan",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 34;
      context__.validate_dims("data initialization", "a", "double",
        std::vector<size_t>{});
      a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 34;
      a = context__.vals_r("a")[(1 - 1)];
      current_statement__ = 35;
      context__.validate_dims("data initialization", "b_log_std", "double",
        std::vector<size_t>{});
      b_log_std = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 35;
      b_log_std = context__.vals_r("b_log_std")[(1 - 1)];
      current_statement__ = 36;
      context__.validate_dims("data initialization", "b_log_mean", "double",
        std::vector<size_t>{});
      b_log_mean = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 36;
      b_log_mean = context__.vals_r("b_log_mean")[(1 - 1)];
      current_statement__ = 37;
      context__.validate_dims("data initialization", "delta", "double",
        std::vector<size_t>{});
      delta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 37;
      delta = context__.vals_r("delta")[(1 - 1)];
      current_statement__ = 38;
      stan::math::validate_non_negative_index("k", "N_f", N_f);
      current_statement__ = 39;
      context__.validate_dims("data initialization", "k", "double",
        std::vector<size_t>{static_cast<size_t>(N_f)});
      k_data__ = Eigen::Matrix<double,-1,1>::Constant(N_f,
                   std::numeric_limits<double>::quiet_NaN());
      new (&k) Eigen::Map<Eigen::Matrix<double,-1,1>>(k_data__.data(), N_f);
      {
        std::vector<local_scalar_t__> k_flat__;
        current_statement__ = 39;
        k_flat__ = context__.vals_r("k");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N_f; ++sym1__) {
          stan::model::assign(k, k_flat__[(pos__ - 1)],
            "assigning variable k", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 40;
      stan::math::validate_non_negative_index("ome", "N_f", N_f);
      current_statement__ = 41;
      context__.validate_dims("data initialization", "ome", "double",
        std::vector<size_t>{static_cast<size_t>(N_f)});
      ome_data__ = Eigen::Matrix<double,-1,1>::Constant(N_f,
                     std::numeric_limits<double>::quiet_NaN());
      new (&ome) Eigen::Map<Eigen::Matrix<double,-1,1>>(ome_data__.data(),
        N_f);
      {
        std::vector<local_scalar_t__> ome_flat__;
        current_statement__ = 41;
        ome_flat__ = context__.vals_r("ome");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N_f; ++sym1__) {
          stan::model::assign(ome, ome_flat__[(pos__ - 1)],
            "assigning variable ome", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 42;
      stan::math::validate_non_negative_index("mu", "2 * N_meas", (2 *
        N_meas));
      current_statement__ = 43;
      mu_data__ = Eigen::Matrix<double,-1,1>::Constant((2 * N_meas),
                    std::numeric_limits<double>::quiet_NaN());
      new (&mu) Eigen::Map<Eigen::Matrix<double,-1,1>>(mu_data__.data(), (2 *
        N_meas));
      current_statement__ = 43;
      stan::model::assign(mu, stan::math::rep_vector(0, (2 * N_meas)),
        "assigning variable mu");
      current_statement__ = 44;
      stan::math::validate_non_negative_index("y_projected", "N_meas", N_meas);
      current_statement__ = 45;
      stan::math::validate_non_negative_index("y_projected", "D", D);
      current_statement__ = 46;
      y_projected = std::vector<Eigen::Matrix<double,-1,1>>(N_meas,
                      Eigen::Matrix<double,-1,1>::Constant(D,
                        std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 47;
      stan::math::validate_non_negative_index("t_projected", "N_time", N_time);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("t_projected", "D", D);
      current_statement__ = 49;
      t_projected = std::vector<Eigen::Matrix<double,-1,1>>(N_time,
                      Eigen::Matrix<double,-1,1>::Constant(D,
                        std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 50;
      stan::math::validate_non_negative_index("k_array", "N_f", N_f);
      current_statement__ = 51;
      k_array = std::vector<double>(N_f,
                  std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 52;
      stan::math::validate_non_negative_index("ome_array", "N_f", N_f);
      current_statement__ = 53;
      ome_array = std::vector<double>(N_f,
                    std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 58;
      for (int i = 1; i <= N_meas; ++i) {
        current_statement__ = 56;
        for (int d = 1; d <= D; ++d) {
          current_statement__ = 54;
          stan::model::assign(y_projected,
            (stan::model::rvalue(
               stan::model::rvalue(y, "y", stan::model::index_uni(i)),
               "y[i]", stan::model::index_uni(1)) *
            stan::model::rvalue(
              stan::model::rvalue(wave_directions, "wave_directions",
                stan::model::index_uni(d)), "wave_directions[d]",
              stan::model::index_uni(1))), "assigning variable y_projected",
            stan::model::index_uni(i), stan::model::index_uni(d));
        }
      }
      current_statement__ = 63;
      for (int j = 1; j <= N_time; ++j) {
        current_statement__ = 61;
        for (int d = 1; d <= D; ++d) {
          current_statement__ = 59;
          stan::model::assign(t_projected,
            (stan::model::rvalue(
               stan::model::rvalue(t, "t", stan::model::index_uni(j)),
               "t[j]", stan::model::index_uni(1)) *
            stan::model::rvalue(
              stan::model::rvalue(wave_directions, "wave_directions",
                stan::model::index_uni(d)), "wave_directions[d]",
              stan::model::index_uni(1))), "assigning variable t_projected",
            stan::model::index_uni(j), stan::model::index_uni(d));
        }
      }
      current_statement__ = 66;
      for (int i = 1; i <= N_f; ++i) {
        current_statement__ = 64;
        stan::model::assign(k_array,
          stan::model::rvalue(k, "k", stan::model::index_uni(i)),
          "assigning variable k_array", stan::model::index_uni(i));
      }
      current_statement__ = 69;
      for (int i = 1; i <= N_f; ++i) {
        current_statement__ = 67;
        stan::model::assign(ome_array,
          stan::model::rvalue(ome, "ome", stan::model::index_uni(i)),
          "assigning variable ome_array", stan::model::index_uni(i));
      }
      current_statement__ = 70;
      stan::math::validate_non_negative_index("sigma_w", "D", D);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("K_self", "N_meas", N_meas);
      current_statement__ = 72;
      stan::math::validate_non_negative_index("K_self", "N_time", N_time);
      current_statement__ = 73;
      stan::math::validate_non_negative_index("K_realimag", "N_meas", N_meas);
      current_statement__ = 74;
      stan::math::validate_non_negative_index("K_realimag", "N_time", N_time);
      current_statement__ = 75;
      K_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 75;
      K_1dim__ = (2 * N_meas);
      current_statement__ = 75;
      stan::math::validate_non_negative_index("K", "2 * N_meas", K_1dim__);
      current_statement__ = 76;
      K_2dim__ = std::numeric_limits<int>::min();
      current_statement__ = 76;
      K_2dim__ = (2 * N_time);
      current_statement__ = 76;
      stan::math::validate_non_negative_index("K", "2 * N_time", K_2dim__);
      current_statement__ = 77;
      L_K_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 77;
      L_K_1dim__ = (2 * N_meas);
      current_statement__ = 77;
      stan::math::validate_non_negative_index("L_K", "2 * N_meas", L_K_1dim__);
      current_statement__ = 78;
      L_K_2dim__ = std::numeric_limits<int>::min();
      current_statement__ = 78;
      L_K_2dim__ = (2 * N_time);
      current_statement__ = 78;
      stan::math::validate_non_negative_index("L_K", "2 * N_time", L_K_2dim__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = D + 1;
  }
  inline std::string model_name() const final {
    return "boostlet_kernel_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.33.1",
             "stancflags = --filename-in-msg=boostlet_kernel.stan"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "boostlet_kernel_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> sigma_w =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(D, DUMMY_VAR__);
      current_statement__ = 1;
      sigma_w = in__.template read_constrain_lb<
                  Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__,
                  D);
      local_scalar_t__ b_log = DUMMY_VAR__;
      current_statement__ = 2;
      b_log = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> K_self =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N_meas, N_time,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> K_realimag =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N_meas, N_time,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> K =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K_1dim__, K_2dim__,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> L_K =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(L_K_1dim__,
          L_K_2dim__, DUMMY_VAR__);
      local_scalar_t__ b = DUMMY_VAR__;
      current_statement__ = 7;
      b = stan::math::pow(10, -(b_log));
      current_statement__ = 8;
      stan::model::assign(K_self,
        cosine_kernel(y_projected, t_projected,
          stan::math::to_vector(sigma_w), k_array, ome_array, pstream__),
        "assigning variable K_self");
      current_statement__ = 9;
      stan::model::assign(K_realimag,
        sine_kernel(y_projected, t_projected, stan::math::to_vector(sigma_w),
          k_array, ome_array, pstream__), "assigning variable K_realimag");
      current_statement__ = 10;
      stan::model::assign(K,
        stan::math::add(
          stan::math::add(
            stan::math::append_row(
              stan::math::append_col(K_self, K_realimag),
              stan::math::append_col(K_realimag, K_self)), Sigma_stan), delta),
        "assigning variable K");
      current_statement__ = 11;
      stan::model::assign(L_K, qr_decompose(K, pstream__),
        "assigning variable L_K");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "b", b, 0);
      {
        current_statement__ = 12;
        lp_accum__.add(stan::math::inv_gamma_lpdf<propto__>(
                         stan::math::to_vector(sigma_w), a, b));
        current_statement__ = 13;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_log, b_log_mean,
                         b_log_std));
        current_statement__ = 16;
        for (int nrep = 1; nrep <= N_reps; ++nrep) {
          current_statement__ = 14;
          lp_accum__.add(stan::math::multi_normal_cholesky_lpdf<propto__>(
                           stan::model::rvalue(h_stan, "h_stan",
                             stan::model::index_uni(nrep)), mu, L_K));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "boostlet_kernel_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> sigma_w =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(D, DUMMY_VAR__);
      current_statement__ = 1;
      sigma_w = in__.template read_constrain_lb<
                  Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__,
                  D);
      local_scalar_t__ b_log = DUMMY_VAR__;
      current_statement__ = 2;
      b_log = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> K_self =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N_meas, N_time,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> K_realimag =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N_meas, N_time,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> K =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K_1dim__, K_2dim__,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> L_K =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(L_K_1dim__,
          L_K_2dim__, DUMMY_VAR__);
      local_scalar_t__ b = DUMMY_VAR__;
      current_statement__ = 7;
      b = stan::math::pow(10, -(b_log));
      current_statement__ = 8;
      stan::model::assign(K_self,
        cosine_kernel(y_projected, t_projected,
          stan::math::to_vector(sigma_w), k_array, ome_array, pstream__),
        "assigning variable K_self");
      current_statement__ = 9;
      stan::model::assign(K_realimag,
        sine_kernel(y_projected, t_projected, stan::math::to_vector(sigma_w),
          k_array, ome_array, pstream__), "assigning variable K_realimag");
      current_statement__ = 10;
      stan::model::assign(K,
        stan::math::add(
          stan::math::add(
            stan::math::append_row(
              stan::math::append_col(K_self, K_realimag),
              stan::math::append_col(K_realimag, K_self)), Sigma_stan), delta),
        "assigning variable K");
      current_statement__ = 11;
      stan::model::assign(L_K, qr_decompose(K, pstream__),
        "assigning variable L_K");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "b", b, 0);
      {
        current_statement__ = 12;
        lp_accum__.add(stan::math::inv_gamma_lpdf<propto__>(
                         stan::math::to_vector(sigma_w), a, b));
        current_statement__ = 13;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_log, b_log_mean,
                         b_log_std));
        current_statement__ = 16;
        for (int nrep = 1; nrep <= N_reps; ++nrep) {
          current_statement__ = 14;
          lp_accum__.add(stan::math::multi_normal_cholesky_lpdf<propto__>(
                           stan::model::rvalue(h_stan, "h_stan",
                             stan::model::index_uni(nrep)), mu, L_K));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "boostlet_kernel_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> sigma_w =
        Eigen::Matrix<double,-1,1>::Constant(D,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      sigma_w = in__.template read_constrain_lb<
                  Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__,
                  D);
      double b_log = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      b_log = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      Eigen::Matrix<double,-1,-1> K_self =
        Eigen::Matrix<double,-1,-1>::Constant(N_meas, N_time,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> K_realimag =
        Eigen::Matrix<double,-1,-1>::Constant(N_meas, N_time,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> K =
        Eigen::Matrix<double,-1,-1>::Constant(K_1dim__, K_2dim__,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> L_K =
        Eigen::Matrix<double,-1,-1>::Constant(L_K_1dim__, L_K_2dim__,
          std::numeric_limits<double>::quiet_NaN());
      double b = std::numeric_limits<double>::quiet_NaN();
      out__.write(sigma_w);
      out__.write(b_log);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 7;
      b = stan::math::pow(10, -(b_log));
      current_statement__ = 8;
      stan::model::assign(K_self,
        cosine_kernel(y_projected, t_projected,
          stan::math::to_vector(sigma_w), k_array, ome_array, pstream__),
        "assigning variable K_self");
      current_statement__ = 9;
      stan::model::assign(K_realimag,
        sine_kernel(y_projected, t_projected, stan::math::to_vector(sigma_w),
          k_array, ome_array, pstream__), "assigning variable K_realimag");
      current_statement__ = 10;
      stan::model::assign(K,
        stan::math::add(
          stan::math::add(
            stan::math::append_row(
              stan::math::append_col(K_self, K_realimag),
              stan::math::append_col(K_realimag, K_self)), Sigma_stan), delta),
        "assigning variable K");
      current_statement__ = 11;
      stan::model::assign(L_K, qr_decompose(K, pstream__),
        "assigning variable L_K");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "b", b, 0);
      if (emit_transformed_parameters__) {
        out__.write(K_self);
        out__.write(K_realimag);
        out__.write(K);
        out__.write(L_K);
        out__.write(b);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> sigma_w =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(D, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(sigma_w,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(D),
        "assigning variable sigma_w");
      out__.write_free_lb(0, sigma_w);
      local_scalar_t__ b_log = DUMMY_VAR__;
      current_statement__ = 2;
      b_log = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, b_log);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "sigma_w",
        "double", std::vector<size_t>{static_cast<size_t>(D)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "b_log", "double",
        std::vector<size_t>{});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> sigma_w =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(D, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> sigma_w_flat__;
        current_statement__ = 1;
        sigma_w_flat__ = context__.vals_r("sigma_w");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= D; ++sym1__) {
          stan::model::assign(sigma_w, sigma_w_flat__[(pos__ - 1)],
            "assigning variable sigma_w", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(0, sigma_w);
      local_scalar_t__ b_log = DUMMY_VAR__;
      current_statement__ = 2;
      b_log = context__.vals_r("b_log")[(1 - 1)];
      out__.write_free_lb(0, b_log);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"sigma_w", "b_log"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"K_self", "K_realimag", "K", "L_K", "b"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(D)},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N_meas),
               static_cast<size_t>(N_time)},
             std::vector<size_t>{static_cast<size_t>(N_meas),
               static_cast<size_t>(N_time)},
             std::vector<size_t>{static_cast<size_t>(K_1dim__),
               static_cast<size_t>(K_2dim__)},
             std::vector<size_t>{static_cast<size_t>(L_K_1dim__),
               static_cast<size_t>(L_K_2dim__)}, std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= D; ++sym1__) {
      param_names__.emplace_back(std::string() + "sigma_w" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "b_log");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N_time; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N_meas; ++sym2__) {
          param_names__.emplace_back(std::string() + "K_self" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N_time; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N_meas; ++sym2__) {
          param_names__.emplace_back(std::string() + "K_realimag" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= K_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "K" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= L_K_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= L_K_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "L_K" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      param_names__.emplace_back(std::string() + "b");
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= D; ++sym1__) {
      param_names__.emplace_back(std::string() + "sigma_w" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "b_log");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N_time; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N_meas; ++sym2__) {
          param_names__.emplace_back(std::string() + "K_self" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N_time; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N_meas; ++sym2__) {
          param_names__.emplace_back(std::string() + "K_realimag" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= K_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "K" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= L_K_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= L_K_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "L_K" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      param_names__.emplace_back(std::string() + "b");
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"sigma_w\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(D) + "},\"block\":\"parameters\"},{\"name\":\"b_log\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"K_self\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N_meas) + ",\"cols\":" + std::to_string(N_time) + "},\"block\":\"transformed_parameters\"},{\"name\":\"K_realimag\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N_meas) + ",\"cols\":" + std::to_string(N_time) + "},\"block\":\"transformed_parameters\"},{\"name\":\"K\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(K_1dim__) + ",\"cols\":" + std::to_string(K_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"L_K\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(L_K_1dim__) + ",\"cols\":" + std::to_string(L_K_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"sigma_w\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(D) + "},\"block\":\"parameters\"},{\"name\":\"b_log\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"K_self\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N_meas) + ",\"cols\":" + std::to_string(N_time) + "},\"block\":\"transformed_parameters\"},{\"name\":\"K_realimag\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N_meas) + ",\"cols\":" + std::to_string(N_time) + "},\"block\":\"transformed_parameters\"},{\"name\":\"K\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(K_1dim__) + ",\"cols\":" + std::to_string(K_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"L_K\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(L_K_1dim__) + ",\"cols\":" + std::to_string(L_K_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (D + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((((N_meas
      * N_time) + (N_meas * N_time)) + (K_1dim__ * K_2dim__)) + (L_K_1dim__ *
      L_K_2dim__)) + 1));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (D + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((((N_meas
      * N_time) + (N_meas * N_time)) + (K_1dim__ * K_2dim__)) + (L_K_1dim__ *
      L_K_2dim__)) + 1));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = boostlet_kernel_model_namespace::boostlet_kernel_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return boostlet_kernel_model_namespace::profiles__;
}
#endif